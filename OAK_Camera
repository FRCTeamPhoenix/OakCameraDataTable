from roboflowoak import RoboflowOak
import cv2
import time
import numpy as np
from networktables import NetworkTables 

if __name__ == '__main__':
    # instantiating an object (rf) with the RoboflowOak module
    rf_1 = RoboflowOak(model="waoidjawiudjoiwaj", confidence=0.05, overlap=0.5,
    version="1", api_key="kifPJfNGf7lywgAW2kzA", rgb=True,
    depth=True, device=None, blocking=True, device_name="OAK-D-PRO-W-1")
    rf_2 = RoboflowOak(model="waoidjawiudjoiwaj", confidence=0.05, overlap=0.5,
    version="1", api_key="kifPJfNGf7lywgAW2kzA", rgb=True,
    depth=True, device=None, blocking=True, device_name="OAK-D-PRO-W-2")
    cameraList = [rf_1]
    # initalizes networktable from ip of geven server
    # connects to networktabel 'SmartDashboard'
    NetworkTables.initialize(server='10.10.21.31')
    cameraDataTable = NetworkTables.getTable('SmartDashboard')
    # Running our model and displaying the video output with detections
    itemPredictionReturn = []
    cameraDataTable.putStringArray("cameraItems", itemPredictionReturn)
    cameraAnglePixle = 95 / 4056
    while True:
        # clear detected notes
        itemPredictionReturn = []
        for cameraNumber in range(len(cameraList)):
            t0 = time.time()
            # The rf.detect() function runs the model inference
            result, frame, raw_frame, depth = cameraList[cameraNumber].detect()
            predictions = result["predictions"]
            t = time.time()-t0
            print("INFERENCE TIME IN MS ", 1/t)
            # loop through each object the camera detects
            for p in predictions:
                 # start a list to contain all data from each object
                 itemPredictionList = []
                 # append information of indavidual object to list
                 for item in p.json():
                     itemPredictionList.append(p.json()[item])
                 objectAngleX = cameraAnglePixle * itemPredictionList[0]
                 objectAngleY = cameraAnglePixle * itemPredictionList[1]
                 objectTrueX = (objectAngleX + 120(cameraNumber + 1)) % 360
                 # only use object if confedence is high enough
                 if itemPredictionList[5] >= 0.4:
                     # create string to contain all info of given object
                     itemPredictionString = f"True, objectTrueX, objectAngleY, {itemPredictionList[2] * itemPredictionList[3]}, {itemPredictionList[4]}, {itemPredictionList[6]}"
                     # add item to object return list
                     itemPredictionReturn.append(itemPredictionString)
        print(itemPredictionReturn)
        # send object list to networktable
        cameraDataTable.putStringArray("cameraItems", itemPredictionReturn)
